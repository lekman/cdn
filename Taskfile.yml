# https://taskfile.dev

version: "3"

includes:
  git:
    taskfile: ./node_modules/@northbridge-security/ai-toolkit/tasks/git.yml
    dir: .
  json:
    taskfile: ./node_modules/@northbridge-security/ai-toolkit/tasks/json.yml
    dir: .
  yaml:
    taskfile: ./node_modules/@northbridge-security/ai-toolkit/tasks/yaml.yml
    aliases:
      - yml
    dir: .
  markdown:
    taskfile: ./node_modules/@northbridge-security/ai-toolkit/tasks/markdown.yml
    aliases:
      - md
    dir: .
  security:
    taskfile: ./node_modules/@northbridge-security/ai-toolkit/tasks/security.yml
    aliases:
      - s
    dir: .
  op:
    taskfile: ./node_modules/@northbridge-security/ai-toolkit/tasks/onepassword.yml
    dir: .

vars:
  PROJECT_NAME: "cdn"

tasks:
  install:
    desc: "Install/upgrade required development tools"
    aliases: [i]
    silent: true
    cmds:
      - |
        set -euo pipefail

        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        CYAN='\033[0;36m'
        RED='\033[0;31m'
        NC='\033[0m'

        echo -e "${CYAN}Installing Development Tools${NC}"
        echo "---"

        # Check if Homebrew is installed
        if ! command -v brew &>/dev/null; then
          echo -e "${RED}Error:${NC} Homebrew is not installed"
          echo "Install from: https://brew.sh"
          exit 1
        fi

        # Install or upgrade bun
        echo -e "${GREEN}Checking bun...${NC}"
        if brew list oven-sh/bun/bun &>/dev/null; then
          echo -e "${YELLOW}Upgrading bun...${NC}"
          brew upgrade oven-sh/bun/bun
        else
          echo -e "${YELLOW}Installing bun...${NC}"
          brew install oven-sh/bun/bun
        fi

        # Install or upgrade go-task
        echo -e "${GREEN}Checking go-task...${NC}"
        if brew list go-task &>/dev/null; then
          echo -e "${YELLOW}Upgrading go-task...${NC}"
          brew upgrade go-task
        else
          echo -e "${YELLOW}Installing go-task...${NC}"
          brew install go-task
        fi

        # Install or upgrade semgrep
        echo -e "${GREEN}Checking semgrep...${NC}"
        if brew list semgrep &>/dev/null; then
          echo -e "${YELLOW}Upgrading semgrep...${NC}"
          brew upgrade semgrep
        else
          echo -e "${YELLOW}Installing semgrep...${NC}"
          brew install semgrep
        fi

        # Install or upgrade pulumi
        echo -e "${GREEN}Checking pulumi...${NC}"
        if brew list pulumi &>/dev/null; then
          echo -e "${YELLOW}Upgrading pulumi...${NC}"
          brew upgrade pulumi
        else
          echo -e "${YELLOW}Installing pulumi...${NC}"
          brew install pulumi
        fi

        # Install project dependencies
        echo ""
        echo -e "${GREEN}Installing project dependencies...${NC}"
        bun install

        echo ""
        echo -e "${GREEN}✓${NC} All tools installed successfully"

  setup:repo:
    desc: "Configure GitHub repository secrets for CI/CD"
    aliases: [setup]
    silent: true
    cmds:
      - |
        set -euo pipefail

        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        CYAN='\033[0;36m'
        RED='\033[0;31m'
        BOLD='\033[1m'
        NC='\033[0m'

        echo -e "${CYAN}GitHub Repository Secret Configuration${NC}"
        echo "---"

        # Required secrets for CI/CD
        SECRETS=(
          "CODECOV_TOKEN"
          "RELEASE_BOT_APP_ID"
          "RELEASE_BOT_PRIVATE_KEY"
          "CLAUDE_CODE_OAUTH_TOKEN"
        )

        # Check gh CLI
        if ! command -v gh &>/dev/null; then
          echo -e "${RED}Error:${NC} GitHub CLI (gh) is not installed"
          echo "Install from: https://cli.github.com"
          exit 1
        fi

        # Check gh authentication — login interactively if needed
        if ! gh auth status &>/dev/null 2>&1; then
          echo -e "${YELLOW}Not logged in to GitHub. Launching login...${NC}"
          gh auth login -p ssh --skip-ssh-key
        fi

        # Ensure gh uses SSH protocol
        CURRENT_PROTO=$(gh config get git_protocol 2>/dev/null || echo "")
        if [ "$CURRENT_PROTO" != "ssh" ]; then
          gh config set git_protocol ssh
          echo -e "${GREEN}✓${NC} Set gh git_protocol to ssh"
        fi

        # Try to resolve secrets from 1Password via .env
        OP_AVAILABLE=false
        if command -v op &>/dev/null; then
          echo -e "${GREEN}1Password CLI detected${NC}"
          # Source resolved env vars if op:export task exists
          EXPORT_FILE=$(task op:export 2>/dev/null) && {
            if [ -f "$EXPORT_FILE" ]; then
              source "$EXPORT_FILE"
              OP_AVAILABLE=true
              echo -e "${GREEN}Secrets resolved from 1Password${NC}"
            fi
          } || {
            echo -e "${YELLOW}Could not resolve secrets from 1Password (task op:export failed)${NC}"
          }
        else
          echo -e "${YELLOW}1Password CLI not found — will prompt for values${NC}"
        fi

        # Prevent sourced tokens from overriding gh CLI auth
        unset GITHUB_TOKEN GH_TOKEN

        echo ""

        # Detect repo from git remote
        REPO=$(gh repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null)
        if [ -z "$REPO" ]; then
          echo -e "${RED}Error:${NC} Could not detect GitHub repository"
          echo "Run from inside a git repo with a GitHub remote"
          exit 1
        fi
        echo -e "Repository: ${GREEN}${REPO}${NC}"
        echo ""

        # Get existing secrets
        EXISTING=$(gh secret list --repo "$REPO" --json name --jq '.[].name' 2>/dev/null || echo "")

        CONFIGURED=0
        SKIPPED=0
        FAILED=0

        for SECRET in "${SECRETS[@]}"; do
          # Check if secret already exists
          if echo "$EXISTING" | grep -q "^${SECRET}$"; then
            echo -e "  ${GREEN}✓${NC} ${SECRET} (already configured)"
            SKIPPED=$((SKIPPED + 1))
            continue
          fi

          # Try to get value from resolved env
          VALUE="${!SECRET:-}"

          if [ -n "$VALUE" ] && [ "$VALUE" != "op://"* ]; then
            # Have a resolved value — set it
            if gh secret set "$SECRET" --repo "$REPO" --body "$VALUE"; then
              echo -e "  ${GREEN}✓${NC} ${SECRET} (set from 1Password)"
              CONFIGURED=$((CONFIGURED + 1))
            else
              echo -e "  ${RED}✗${NC} ${SECRET} (failed to set)"
              FAILED=$((FAILED + 1))
            fi
          else
            # Prompt for value interactively
            echo -e "  ${YELLOW}?${NC} ${SECRET} — no resolved value available"

            if [ "$SECRET" = "RELEASE_BOT_PRIVATE_KEY" ]; then
              echo -e "    ${CYAN}Paste PEM private key (end with empty line):${NC}"
              PEM_VALUE=""
              while IFS= read -r line; do
                [ -z "$line" ] && break
                PEM_VALUE="${PEM_VALUE}${line}"$'\n'
              done

              if [ -n "$PEM_VALUE" ]; then
                if echo "$PEM_VALUE" | gh secret set "$SECRET" --repo "$REPO"; then
                  echo -e "    ${GREEN}✓${NC} ${SECRET} (set from input)"
                  CONFIGURED=$((CONFIGURED + 1))
                else
                  echo -e "    ${RED}✗${NC} ${SECRET} (failed to set)"
                  FAILED=$((FAILED + 1))
                fi
              else
                echo -e "    ${YELLOW}⊘${NC} ${SECRET} (skipped)"
                FAILED=$((FAILED + 1))
              fi
            else
              read -rp "    Enter value (or press Enter to skip): " INPUT_VALUE
              if [ -n "$INPUT_VALUE" ]; then
                if gh secret set "$SECRET" --repo "$REPO" --body "$INPUT_VALUE"; then
                  echo -e "    ${GREEN}✓${NC} ${SECRET} (set from input)"
                  CONFIGURED=$((CONFIGURED + 1))
                else
                  echo -e "    ${RED}✗${NC} ${SECRET} (failed to set)"
                  FAILED=$((FAILED + 1))
                fi
              else
                echo -e "    ${YELLOW}⊘${NC} ${SECRET} (skipped)"
                FAILED=$((FAILED + 1))
              fi
            fi
          fi
        done

        echo ""
        echo -e "${BOLD}Summary:${NC}"
        echo -e "  Configured: ${GREEN}${CONFIGURED}${NC}"
        echo -e "  Existing:   ${YELLOW}${SKIPPED}${NC}"
        echo -e "  Remaining:  ${RED}${FAILED}${NC}"

        if [ "$FAILED" -gt 0 ]; then
          echo ""
          echo -e "${YELLOW}Re-run 'task setup:repo' after resolving remaining secrets${NC}"
        else
          echo ""
          echo -e "${GREEN}✓${NC} All repository secrets configured"
        fi

  clear:
    desc: "Remove caches and temp files, reinstall dependencies"
    aliases: [cls]
    silent: true
    cmds:
      - |
        set -euo pipefail

        GREEN='\033[0;32m'
        CYAN='\033[0;36m'
        NC='\033[0m'

        echo -e "${CYAN}Clearing caches and temp files${NC}"

        for dir in .tmp .logs .turbo coverage dist build node_modules/.cache; do
          if [ -d "$dir" ]; then
            rm -rf "$dir"
            echo -e "  ${GREEN}removed${NC} $dir"
          fi
        done

        # Remove TypeScript build info
        find . -name '*.tsbuildinfo' -not -path './node_modules/*' -delete 2>/dev/null && \
          echo -e "  ${GREEN}removed${NC} *.tsbuildinfo" || true

        # Remove node_modules to guarantee clean dependency tree
        if [ -d "node_modules" ]; then
          rm -rf node_modules
          echo -e "  ${GREEN}removed${NC} node_modules"
        fi

        echo ""
      - task: install

  default:
    desc: "Show available cdn tasks"
    aliases: [help, h]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        BLUE='\033[0;34m'
        CYAN='\033[0;36m'
        BOLD='\033[1m'
        NC='\033[0m'

        echo -e "${BOLD}@lekman/cdn — Edge Cache CDN API${NC}"
        echo ""
        echo "Command                            Alias     Description"
        echo "────────────────────────────────────────────────────────────────────────────────"
        echo -e "${BOLD}Setup:${NC}"
        echo -e "  ${GREEN}task install${NC}                     ${YELLOW}i${NC}         Install/upgrade required tools"
        echo -e "  ${GREEN}task clear${NC}                       ${YELLOW}cls${NC}       Remove caches, reinstall dependencies"
        echo -e "  ${GREEN}task setup:repo${NC}                  ${YELLOW}setup${NC}     Configure GitHub repo secrets"
        echo ""
        echo -e "${BOLD}Development:${NC}"
        echo -e "  ${GREEN}task lint${NC}                        ${YELLOW}l${NC}         Run linting checks"
        echo -e "  ${GREEN}task format${NC}                      ${YELLOW}fmt${NC}       Format code"
        echo -e "  ${GREEN}task typecheck${NC}                   ${YELLOW}tc${NC}        Run TypeScript type checking"
        echo -e "  ${GREEN}task test${NC}                        ${YELLOW}t${NC}         Run tests"
        echo -e "  ${GREEN}task test:coverage${NC}               ${YELLOW}cov${NC}       Run tests with coverage report"
        echo -e "  ${GREEN}task quality${NC}                     ${YELLOW}q${NC}         Run all quality checks"
        echo ""
        echo -e "${BOLD}Infrastructure:${NC}"
        echo -e "  ${GREEN}task infra:init${NC}                  ${YELLOW}init${NC}      Initialize Pulumi stacks (dev + prod)"
        echo -e "  ${GREEN}task infra:preview${NC}               ${YELLOW}pre${NC}       Preview changes (default: dev)"
        echo -e "  ${GREEN}task infra:up${NC}                    ${YELLOW}up${NC}        Deploy to Azure (default: dev)"
        echo -e "  ${GREEN}task infra:down${NC}                  ${YELLOW}down${NC}      Destroy resources (default: dev)"
        echo -e "  ${GREEN}task infra:outputs${NC}               ${YELLOW}out${NC}       Show stack outputs as JSON"
        echo -e "  ${GREEN}task infra:refresh${NC}               ${YELLOW}ref${NC}       Refresh Pulumi state from Azure"
        echo ""
        echo -e "${BOLD}Security:${NC}"
        echo -e "  ${GREEN}task security:scan${NC}               ${YELLOW}s:s${NC}       Run semgrep security scanner"
        echo ""
        echo -e "${BOLD}Claude Code:${NC}"
        echo -e "  ${GREEN}task claude:plan${NC}                 ${YELLOW}plan${NC}      Open latest Claude plan in IDE"
        echo -e "  ${GREEN}task claude:task${NC}                 ${YELLOW}ctask${NC}     Open latest Claude task in IDE"
        echo ""
        echo -e "${BOLD}Task Libraries:${NC}"
        echo -e "  ${GREEN}task git:<command>${NC}                         Git & GitHub operations"
        echo -e "  ${GREEN}task json:<command>${NC}                        JSON linting & validation"
        echo -e "  ${GREEN}task yaml:<command>${NC}              ${YELLOW}yml${NC}       YAML linting & validation"
        echo -e "  ${GREEN}task markdown:<command>${NC}          ${YELLOW}md${NC}        Markdown linting & validation"
        echo -e "  ${GREEN}task security:<command>${NC}          ${YELLOW}s${NC}         Security scanning tools"
        echo -e "  ${GREEN}task op:<command>${NC}                          1Password secret resolution"
        echo ""
        echo -e "${BLUE}Run 'task --list' to see all available tasks${NC}"

  lint:
    desc: "Run linting checks"
    aliases: [l]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        NC='\033[0m'

        echo -e "${GREEN}Running linting...${NC}"
        bunx turbo run lint

  format:
    desc: "Format code"
    aliases: [fmt]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        NC='\033[0m'

        echo -e "${GREEN}Formatting code...${NC}"
        bun run format

  typecheck:
    desc: "Run TypeScript type checking"
    aliases: [tc]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        NC='\033[0m'

        echo -e "${GREEN}Type checking...${NC}"
        bunx turbo run typecheck

  test:
    desc: "Run tests"
    aliases: [t]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        NC='\033[0m'

        echo -e "${GREEN}Running tests...${NC}"
        bunx turbo run test

  test:coverage:
    desc: "Run tests with coverage report"
    aliases: [cov]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        CYAN='\033[0;36m'
        NC='\033[0m'

        echo -e "${GREEN}Running unit tests with coverage...${NC}"
        bunx turbo run test:coverage
        echo ""
        echo -e "${CYAN}Coverage report generated:${NC}"
        echo -e "  LCOV: ${GREEN}coverage/lcov.info${NC}"

  ide:open:
    desc: "Open a file in the active IDE (detects running editor)"
    internal: true
    silent: true
    cmds:
      - |
        set -euo pipefail
        FILE="{{.FILE}}"
        if [ -z "$FILE" ]; then
          echo "Error: FILE variable not set"
          exit 1
        fi

        # Known CLI paths (macOS installs to /usr/local/bin)
        CLI_INSIDERS="/usr/local/bin/code-insiders"
        CLI_CODE="/usr/local/bin/code"
        CLI_CURSOR="/usr/local/bin/cursor"

        # Detect running IDE from process list (most specific first)
        IDE=""
        if pgrep -f "Code - Insiders" &>/dev/null && [ -x "$CLI_INSIDERS" ]; then
          IDE="$CLI_INSIDERS"
        elif pgrep -f "Cursor Helper" &>/dev/null && [ -x "$CLI_CURSOR" ]; then
          IDE="$CLI_CURSOR"
        elif pgrep -f "Visual Studio Code.app" &>/dev/null && [ -x "$CLI_CODE" ]; then
          IDE="$CLI_CODE"
        fi

        # Fall back to whatever CLI is available
        if [ -z "$IDE" ]; then
          for cmd in "$CLI_INSIDERS" "$CLI_CURSOR" "$CLI_CODE"; do
            if [ -x "$cmd" ]; then
              IDE="$cmd"
              break
            fi
          done
        fi

        if [ -n "$IDE" ]; then
          "$IDE" --reuse-window "$FILE"
        elif [ -n "${EDITOR:-}" ]; then
          $EDITOR "$FILE"
        else
          open "$FILE"
        fi

  claude:plan:
    desc: "Open the latest Claude Code plan in the IDE"
    aliases: [plan]
    silent: true
    cmds:
      - |
        set -euo pipefail
        PLANS_DIR="$HOME/.claude/plans"
        if [ ! -d "$PLANS_DIR" ]; then
          echo "No plans directory found at $PLANS_DIR"
          exit 1
        fi
        LATEST=$(ls -t "$PLANS_DIR"/*.md 2>/dev/null | head -1)
        if [ -z "$LATEST" ]; then
          echo "No plan files found"
          exit 1
        fi
        echo "Opening: $LATEST"
      - task: ide:open
        vars:
          FILE:
            sh: ls -t "$HOME/.claude/plans"/*.md 2>/dev/null | head -1

  claude:task:
    desc: "Open the latest Claude Code task in the IDE"
    aliases: [ctask]
    silent: true
    cmds:
      - |
        set -euo pipefail
        TASKS_DIR="$HOME/.claude/tasks"
        if [ ! -d "$TASKS_DIR" ]; then
          echo "No tasks directory found at $TASKS_DIR"
          exit 1
        fi
        LATEST_DIR=$(ls -dt "$TASKS_DIR"/*/ 2>/dev/null | head -1)
        if [ -z "$LATEST_DIR" ]; then
          echo "No task directories found"
          exit 1
        fi
        # Look for .md files; fall back to non-hidden files
        LATEST=$(ls -t "$LATEST_DIR"*.md 2>/dev/null | head -1)
        if [ -z "$LATEST" ]; then
          LATEST=$(find "$LATEST_DIR" -maxdepth 1 -not -name '.*' -type f 2>/dev/null | head -1)
        fi
        if [ -z "$LATEST" ]; then
          echo "No files found in $LATEST_DIR"
          echo "Task dirs contain only lock files — tasks may not have persisted content yet"
          exit 1
        fi
        echo "Opening: $LATEST"
      - task: ide:open
        vars:
          FILE:
            sh: |
              DIR=$(ls -dt "$HOME/.claude/tasks"/*/ 2>/dev/null | head -1)
              ls -t "$DIR"*.md 2>/dev/null | head -1 || find "$DIR" -maxdepth 1 -not -name '.*' -type f 2>/dev/null | head -1

  quality:
    desc: "Run all quality checks (lint, typecheck, security, test)"
    aliases: [q]
    silent: true
    cmds:
      - |
        GREEN='\033[0;32m'
        CYAN='\033[0;36m'
        NC='\033[0m'

        echo -e "${CYAN}Running Quality Checks${NC}"
        echo "---"
      - task: lint
      - task: typecheck
      - task: security:scan
      - task: test
      - |
        GREEN='\033[0;32m'
        NC='\033[0m'

        echo ""
        echo -e "${GREEN}✓${NC} All quality checks passed"

  infra:check-prereqs:
    desc: "Check infrastructure prerequisites (az, pulumi, login)"
    internal: true
    silent: true
    cmds:
      - |
        set -euo pipefail
        RED='\033[0;31m'
        CYAN='\033[0;36m'
        NC='\033[0m'

        if ! command -v pulumi &>/dev/null; then
          echo -e "${RED}Error:${NC} Pulumi is not installed."
          echo -e "  Install: ${CYAN}brew install pulumi${NC}"
          echo -e "  Or run:  ${CYAN}task install${NC}"
          exit 1
        fi

        if ! command -v az &>/dev/null; then
          echo -e "${RED}Error:${NC} Azure CLI is not installed."
          echo -e "  Install: ${CYAN}brew install azure-cli${NC}"
          exit 1
        fi

        if ! az account show &>/dev/null 2>&1; then
          echo -e "${RED}Error:${NC} Not logged into Azure."
          echo -e "  Run: ${CYAN}az login${NC}"
          exit 1
        fi

        if ! pulumi whoami &>/dev/null 2>&1; then
          echo -e "${RED}Error:${NC} Not logged into Pulumi."
          echo -e "  Run: ${CYAN}pulumi login${NC}"
          exit 1
        fi

  infra:init:
    desc: "Initialize Pulumi stacks (dev and prod)"
    silent: true
    aliases: [init]
    dir: infra
    deps: [infra:check-prereqs]
    cmds:
      - |
        set -euo pipefail
        GREEN='\033[0;32m'
        CYAN='\033[0;36m'
        NC='\033[0m'

        echo -e "${CYAN}Initializing Pulumi stacks${NC}"
        pulumi stack init dev 2>/dev/null || echo -e "${GREEN}dev stack already exists${NC}"
        pulumi stack init prod 2>/dev/null || echo -e "${GREEN}prod stack already exists${NC}"
        echo -e "${GREEN}✓${NC} Stacks initialized"

  infra:preview:
    desc: "Preview infrastructure changes (usage: task infra:preview -- dev)"
    aliases: [pre]
    silent: true
    dir: infra
    vars:
      STACK: '{{.CLI_ARGS | default "dev"}}'
    deps: [infra:check-prereqs]
    cmds:
      - |
        set -euo pipefail
        GREEN='\033[0;32m'
        CYAN='\033[0;36m'
        NC='\033[0m'
        echo -e "${CYAN}Previewing infrastructure changes for ${GREEN}{{.STACK}}${NC}"
        pulumi preview -s "{{.STACK}}"

  infra:up:
    desc: "Deploy infrastructure to Azure (usage: task infra:up -- dev)"
    aliases: [up]
    silent: true
    dir: infra
    vars:
      STACK: '{{.CLI_ARGS | default "dev"}}'
    deps: [infra:check-prereqs]
    cmds:
      - |
        set -euo pipefail
        pulumi up -s "{{.STACK}}" --yes --skip-preview --suppress-outputs

  infra:down:
    desc: "Destroy infrastructure on Azure (usage: task infra:down -- dev)"
    aliases: [down]
    silent: true
    dir: infra
    vars:
      STACK: '{{.CLI_ARGS | default "dev"}}'
    deps: [infra:check-prereqs]
    cmds:
      - |
        set -euo pipefail
        pulumi destroy -s "{{.STACK}}" --yes --skip-preview --suppress-outputs

  infra:outputs:
    desc: "Show stack outputs as JSON (usage: task infra:outputs -- dev)"
    aliases: [out]
    silent: true
    dir: infra
    vars:
      STACK: '{{.CLI_ARGS | default "dev"}}'
    deps: [infra:check-prereqs]
    cmds:
      - pulumi stack output -s "{{.STACK}}" --json

  infra:refresh:
    desc: "Refresh Pulumi state from Azure (usage: task infra:refresh -- dev)"
    aliases: [ref]
    silent: true
    dir: infra
    vars:
      STACK: '{{.CLI_ARGS | default "dev"}}'
    deps: [infra:check-prereqs]
    cmds:
      - |
        set -euo pipefail
        pulumi refresh -s "{{.STACK}}" --skip-preview --clear-pending-creates --suppress-outputs --yes
